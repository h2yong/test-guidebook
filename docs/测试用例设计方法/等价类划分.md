---
title: 等价类划分法
description: 等价类划分法是一种典型的，并且是最基础的黑盒测试用例设计方法
keywords: [等价类, 等价类划分, 测试用例, 测试用例设计, 黑盒测试, 基础测试用例设计, 基础测试用例设计, 有效等价类, 无效等价类]
---
# 等价类划分
## 定义（What）
等价类划分法是一种典型的，并且是最基础的黑盒测试用例设计方法。**采用等价类划分法时，完全不用考虑程序内部结构，设计测试用例的唯一依据是软件需求规格说明书。**

所谓等价类，是输入条件的一个子集合，该输入集合中的数据对于揭示程序中的错误是等价的。从每一个子集中选取少数具有代表性的数据，从而生成测试用例。

等价类又分为**有效等价类**和**无效等价类**。有效等价类代表对程序有效的输入（利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能），而无效等价类则是其他任何可能的输入（即不正确的输入值）。有效等价类和无效等价类都是使用等价类划分法设计用例时所必须的，因为**被测程序若是正确的，就应该既能接受有效的输入，也能接受无效输入的考验。**

## 为什么使用该方法？（Why）
理想的测试，是从所有可能的输入中找出某个小的子集，并且是可能发现错误最多的子集。即：**使用最少的测试数据，达到最好的测试质量（最高性价比）**。

这个子集如何确定？可以借助测试用例的两个特性：测试用例数量达到最少；某个测试用例要能覆盖大部分其他测试用例。第二个特性就暗示我们，应该尽量将程序输入范围进行划分，将其划分为有限数量的等价类，这样就可以合理地假设测试每个等价类的代表性数据等同于测试该类的其他任何数据。这两种特性形成了称为等价类划分的黑盒测试方法。

因此，**等价类划分是黑盒测试最基本的方法**。

## 如何划分等价类？（How）
在给定了输入或外部条件之后，等价类的划分原则如下：  
- 如果输入条件规定了一个取值范围（例如，“数量可以是1到999”），那么就应确定出一个有效等价类（1<数量<999）,以及两个无效等价类（数量<1，数量>999）。
- 如果输入条件规定了取值的个数（例如，“汽车可登记一至六名车主”），那么就应确定出一个有效等价类和两个无效等价类（没有车主，或车主多于六个）。
- 如果输入条件规定了一个输入值的集合，而且有理由认为程序会对每个值进行不同处理（例如，“交通工具的类型必须是公共汽车、卡车、出租车、火车或摩托车”），那么就应为每个输入值确定一个有效等价类和一个无效等价类（例如，“拖车”）。
- 如果存在输入条件规定了“必须是”的情况，例如“标识符的第一个字符必须是字母”，那么就应确定一个有效等价类（首字符是字母）和一个无效等价类（首字符不是字母）。
- 以上是基于字面上的需求划分的等价类，而细化等价类依据的是数据在内存或数据库中存储的类型。（举例，测试加法器，两个文本框，要求输入-99~99之间的整数。整数的存储在计算机底层中会使用不同的算法，正整数和负整数算法不同。所以测试时正整数和负整数应该分开来测（一般对有效等价类数据应用，无效等价类数据一般不需要正、负分别测）。所以将有效等价类细分为：-99--（-1）负整数、0—99 正整数。

> Tips：如果有任何理由可以认为程序并未等同地处理等价类中的元素，那么应该将这个等价类再划分为小一些的等价类。

**划分等价类的标准：**
- 完备测试、避免冗余;
- 划分等价类重要的是：集合的划分，划分为互不相交的一组子集，而子集的并是整个集合;
- 并是整个集合：完备性;
- 子集互不相交：保证一种形式的无冗余性;
- 同一类中标识（选择）一个测试用例，同一等价类中，往往处理相同，相同处理映射到"相同的执行路径"。

## 用例设计步骤
1. 划分等价类
   > 划分等价类是选取每一个输入条件（通常是规格说明中的一个句子或短语）并将其划分为两个或更多的组。注意，我们划分了两类等价类：有效等价类代表对程序的有效输入，而无效等价类代表的则是其他任何可能的输入条件（即不正确的输入值）。这样，我们就遵循了测试原则，即要注意无效和未预料到的输入情况。
2. 建立等价类表
   > 划分等价类后，应建立等价类表，列出与每一个输入条件对应的有效等价类和无效等价类，并为每个等价类设置一个唯一的编号。  
   
   **使用下面的表格有利于确定测试用例**  

   | 条件   | 有效等价类       | 编号   | 无效等价类 | 编号   |
   | ------ | ---------------- | ------ | ---------- | ------ |
   | &nbsp; | &nbsp;    &nbsp; | &nbsp; | &nbsp;     | &nbsp; |

3. 生成测试用例  
   现在利用等价类表来生成测试用例，其过程如下：  
   - 编写新的测试用例，尽可能多地覆盖那些尚未被涵盖的有效等价类，直到所有的有效等价类都被测试用例所覆盖（包含进去）。
   - 编写新的用例，每次覆盖一个（仅一个）尚未被涵盖的无效等价类，直到所有的无效等价类都被测试用例所覆盖（包含进去）。

> Tips：用测试用例每次只覆盖1个无效等价类，是因为**某些特定的输入错误检查可能会屏蔽或取代其他输入错误检查**。举例，如果规格说明规定了“请输入书籍类型（硬皮、软皮或活页）及数量（1~999）”，代表两个错误输入（书籍类型错误，数量错误）的测试用例“（XYZ，0）”，很可能不会执行对数量的检查，因为程序也许会提示“XYZ是未知的书籍类型”，就不检查输入的其余部分了。

## 使用场景
有**数据输入（编辑框）**的地方，可以使用等价类划分法。例如用户登录、注册、新建、查询。

## 实战演练
### 功能描述
NextDate（年，月，日）是三个变量的函数。函数返回输入日期的下一个日期。变量年份，月份，日期都是整数值，且满足下面的条件： 1900<=年<=2060 ,1<=月<=12, 1<=日<=31

### 参考答案
**等价类划分**

| 条件 | 有效等价类   | 编号 | 无效等价类 | 编号 |
| ---- | ------------ | ---- | ---------- | ---- |
| 年   | 闰年         | 1    | 年<=1900   | 11   |
|      | 平年         | 2    | 年>=2060   | 12   |
| 月   | 1,3,5,7,8,10 | 3    | 月<1       | 13   |
|      | 4,6,9,11     | 4    | 月>12      | 14   |
|      | 2月          | 5    |            |      |
|      | 12月         | 6    |            |      |
| 日   | [1,28]       | 7    | 日<1       | 15   |
|      | 29           | 8    | 日>31      | 16   |
|      | 30           | 9    |            |      |
|      | 31           | 10   |            |      |

**测试用例**
1. 覆盖等价类2,3,10：测试输入=(2001,7,31)，预期结果=(2001,8,1)
2. 覆盖等价类2,4,9：测试输入=(2006,4,30)，预期结果=(2006,5,1)
3. 覆盖等价类1,5,8：测试输入=(2000,2,29)，预期结果=(2000,3,1)
4. 覆盖等价类2,6,7：测试输入=(2001,12,15)，预期结果=(2001,12,16)
5. 覆盖等价类11,3,7：测试输入=(1830,3,19)， 预期结果=“输入错误!”
6. 覆盖等价类12,3,7：测试输入=(3000,3,19)， 预期结果=“输入错误!”
7. 覆盖等价类1,13,7：测试输入=(2004,-2,10)，预期结果=“输入错误!”
8. 覆盖等价类1,14,7：测试输入=(2004,15,10)，预期结果=输入错误!”
9. 覆盖等价类1,3,15：测试输入=(2004,8,-2)， 预期结果=“输入错误!”
10. 覆盖等价类1,3,16：测试输入=(2004,8,38)，预期结果=“输入错误!”

### 说明
测试用例涵盖了大部分需测试的要点，但仍有些遗漏，例如年底、平年的二月等。

如何再次提高测试用例质量呢？  
1. 在实际测试时，可以考虑增加一些测试用例来补充，或者通过其他测试用例设计方法来补充等价类划分无法覆盖到的测试点（实际中会使用错误猜测法）。
2. 根据功能规格说明，选取恰当的测试用例设计方法。Nextdate各个输入变量之间其实并不是完全独立的，在设计测试用例时并没有考虑到这点，可以使用：
   * 各个变量之间进行全组合
   * 判定表
3. 综合运用多种测试用例设计方法，以求得测试质量与成本之间的平衡